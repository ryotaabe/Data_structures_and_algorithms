# Data_structures_and_algorithms

データ構造とアルゴリズムについて講義で学んだことなどをメモとして残したいと思う。

## 参考資料

本稿の作成に当たっては柴田望洋氏の新・明解 Javaで学ぶアルゴリズムとデータ構造を参照した。ド定番すぎて今更感想などを述べる必要もないかと思うが、ソフトウェアに携わるすべてのエンジニアに必要なアルゴリズムの知識について体系的に学べる書籍である是非参考にしていただきたい。

## Call by Refernce と Call by value

Call by Refernce（参照渡し） と Call by value（値渡し）は引数の渡し方を表す。以下にその例を示す。
 - 基本データ型：char,int,float,doubleなど
 - 参照型：配列、インスタンスなど

 - Call by value：基本データ型
 - Call by Refernce：参照型

Call by Refernceの例を以下に示す。

    int a[]={1};
    int b[]=a;
    b[0]=2;
    system.out.println(a[0]);

この例の場合は２が出力される。
このように、Call by valueは変数の値を直接渡すことに対して、Call by Refernceはアドレスを渡すという違いがある。
上記の例では'b[0]=2;'によって配列aのアドレスそのものが書き換えられている。

## 探索

探索とはある条件を満たすデータを探し出すことである。
探索は何らかの項目に着目する。この着目する項目のことをキー(key)と呼ぶ。
探索方法には以下のような物がある。
 - 線形探索
 - 二分探索
 - ハッシュ法
   - チェイン法
   - オープンアドレス法

## 線形探索(逐次探索)

線形探索は要素が直線上に並んだ配列から、目的とするキー値をもつ要素に一致するまで先頭から順番に要素を走査するこで実現する。
以下にその例を示す

    while(true){
      if(i==n) return -1;
      if(a[i]==key) return i;
      i++
    }

## 番兵法

線形探索は繰り返しのたびに２つの終了条件をチェックしているため、ムダが多い。そこでアルゴリズムの改良を行い、コストを半分に抑えるのが次に紹介する番兵法である。
番兵法は探索の前に、探索するキー値と同じ値を末尾の要素に格納する。このとき、格納するデータを番兵とする。このようにすると、目的の値が存在しなくても、終了条件が成立するため、繰り返しの終了判定を減らすことが出来る。以下に例を示す。

    a[n]=key;
    while(true){
      if(a[i]==key)
        break;
    i++;
    }
    return i==n ? -1 : i;

## 二分探索

二分探索は要素がキーの昇順もしくは降順にソートされている配列から探索を行うアルゴリズムである。以下にその手順を示す。

 1. 昇順または降順にソート
 1. 配列の中央に着目
 1. 探索対象の絞り込み
    1.  a[pc]<keyのとき、plをpc+1
    2.  a[pc]>keyのとき、prをpc-1
 1. 終了条件
    1. a[pc]とkeyが一致
    2. 探索範囲がなくなる。

### a[pc]<keyのとき

a[pl]~a[pc]はkeyよりも小さいことが明らかである。よって、探索対象外の探索範囲は中央a[pc]より後方のa[pc+1]~a[pr]になる。そこで、plの値をpc+1に更新する。

### a[pc]>keyのとき

a[pl]~a[pc]はkeyよりも大きいことが明らかである。よって、探索対象外の探索範囲は中央a[pc]より前方のa[pl]~a[pc-1]になる。そこで、prの値をpc-1に更新する。

### 終了条件

1. a[pc]とkeyが一致
2. 探索範囲がなくなった。

よって、__pl<=pr__ plがprよりも大きくなって探索失敗
以下に二分探索を行うプログラムを示す。

```Java
for (int i=i;i<num;i++){
  do{
    System.out.print("x["+i+"]:");
    x[i]=stdIn.nextInt();
  } while (x[i]<x[i-1]); //１つ前の要素より小さければ再入力
}
```

## 計算量(オーダ)

プログラムの実行速度や実行時間は動作するハードやソフトによって変わるため、アルゴリズムの性能を客観的に評価するための尺度として、用いられるのが計算量である。
計算量は以下の２つに分かれる。

1. 時間計算量  
   実行に要する時間を評価したもの
2. 領域計算量  
   どのくらいの記憶域やファイル域が必要であるかを評価したもの

この他に各ステップの実行回数のオーダを算出する __実行回数__ などがある。

以下に線形探索における各ステップの実行回数とそのオーダを示す。

||線形探索|実行回数|オーダ|
|:--:|:--:|:--:|:--:|
|1|int i=0;|1|O(1)|
|2|while(i < n){|$\frac{n}{2}$|O(n)|
|3| if(a[i]==key)|$\frac{n}{2}$|O(n)|
|4|   return i;|1|O(1)|
|5|   i++;|$\frac{n}{2}$|O(n)|
|6|return -1;|1|O(1)|

線形探索のアルゴリズムのオーダを求めると、以下の様になる。

O(1)+O(n)+O(n)+O(1)+O(1)=O(n)

__このように、２つの計算からなるアルゴリズムは、より大きい方の計算量に支配される。３つ以上も同様に最も大きい計算量に支配される。__

以下に計算量と増加率の図を示す。




